<html>
<head><title>Dasynq manual</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="content">
<h1>Dasynq manual</h1>

This is the manual for the <b>Dasynq</b> event loop library (version 1.1.6).

<ul>
<li><a href="#intro">Introduction</a></l1>
<li>Reference
  <ul>
  <li><a href="event_loop.html">event_loop, event_loop_n, event_loop_th</a></li>
  <li><a href="fd_watcher.html">fd_watcher, fd_watcher_impl</a></li>
  <li><a href="bidi_fd_watcher.html">bidi_fd_watcher, bidi_fd_watcher_impl</a></li>
  <li><a href="signal_watcher.html">signal_watcher, signal_watcher_impl</a></li>
  <li><a href="child_proc_watcher.html">child_proc_watcher, child_proc_watcher_impl</a></li>
  <li><a href="timer.html">timer, timer_impl</a></li>
  <li><a href="dasynq-namespace.html">dasynq namespace synopsis</a></li>
  </ul>
</ul>

<hr>
<a name="intro"></a><h2>Introduction</h2>

<p>An event loop library provides a means for waiting on events that occur asynchronously. One good
example is network input/output; in a server with multiple client connections, a mechanism is needed to
wait until data is available, or until it is possible to write data, to one or more of the current
connections (and to be able to identify <i>which</i> connections are ready). Dasynq is a multi-platform,
thread-safe C++ library which provides such functionality.</p>

<p>Note that an event loop generally supports managing various different kinds of event. Dasynq can be used
for detecting: 

<ul>
<li>read/write readiness on sockets, pipes, and certain devices including terminals and serial lines;</li>
<li>connections to listening sockets;</li>
<li>reception of POSIX signals (such as SIGTERM); and</li>
<li>child process status notifications (termination etc).</li>
</ul>

It also supports one-shot and periodic timers.</p>

<p>Dasynq is fully thread safe, allowing events to be polled and processed on any thread. There are
<i>some</i> limitations on the use the Dasynq API in a multi-threaded application. However, when used in a
single-thread application, the API is just about as straight-forward as the API of most other event loop
libraries.</p>

<p>Dasynq is also intended to allow development of extremely robust client applications. Where possible,
it allows pre-allocation of resources to prevent allocation failures from occurring at inopportune moments
during program execution. </p>

<h3>Caveat</h3>

<p>The <a href="http://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#cxx-throw">Itanium C++ ABI</a>,
which is the basis for the ABI on many platforms (for instance it is the
ABI which the Sys V ABI for x86-64 defers to), has one very unfortunate design flaw: throwing an
exception requires making a heap allocation (and if the allocation fails, the process terminates).
Implementations have an "emergency allocation pool" for exceptions which should mean that the
allocation fails only in truly exceptional circumstances, but the possibility is there.
Unfortunately Dasynq at this stage sometimes uses exceptions (in some cases handling them
internally rather than exposing them to the user of the API) and in theory could trigger process
termination on these platforms. I consider this a bug in the ABI and in the platforms implementing
it, however a future version of Dasynq may endeavour to avoid use of exceptions entirely (or at
least make it possible for the client to avoid unwittingly triggering exceptions).</p>

</div>
</body>
</html>
